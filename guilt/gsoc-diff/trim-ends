diff --git a/xdiff/xprepare.c b/xdiff/xprepare.c
index 3ebad0f..c9d7d2f 100644
--- a/xdiff/xprepare.c
+++ b/xdiff/xprepare.c
@@ -26,6 +26,7 @@
 #define XDL_KPDIS_RUN 4
 #define XDL_MAX_EQLIMIT 1024
 #define XDL_SIMSCAN_WINDOW 100
+#define XDL_TRIM_BLK 128
 
 
 typedef struct s_xdlclass {
@@ -53,11 +54,11 @@ static void xdl_free_classifier(xdlclassifier_t *cf);
 static int xdl_classify_record(xdlclassifier_t *cf, xrecord_t **rhash, unsigned int hbits,
 			       xrecord_t *rec);
 static int xdl_prepare_ctx(mmfile_t *mf, long narec, xpparam_t const *xpp,
-			   xdlclassifier_t *cf, xdfile_t *xdf);
+			   xdlclassifier_t *cf, xdfile_t *xdf,
+			   xrecord_t **arec, long *ntail);
 static void xdl_free_ctx(xdfile_t *xdf);
 static int xdl_clean_mmatch(char const *dis, long i, long s, long e);
 static int xdl_cleanup_records(xdfile_t *xdf1, xdfile_t *xdf2);
-static int xdl_trim_ends(xdfile_t *xdf1, xdfile_t *xdf2);
 static int xdl_optimize_ctxs(xdfile_t *xdf1, xdfile_t *xdf2);
 
 
@@ -102,9 +103,10 @@ static int xdl_classify_record(xdlclassifier_t *cf, xrecord_t **rhash, unsigned
 	line = rec->ptr;
 	hi = (long) XDL_HASHLONG(rec->ha, cf->hbits);
 	for (rcrec = cf->rchash[hi]; rcrec; rcrec = rcrec->next)
-		if (rcrec->ha == rec->ha &&
+		if (rec->ha == 0 ||
+			(rcrec->ha == rec->ha &&
 				xdl_recmatch(rcrec->line, rcrec->size,
-					rec->ptr, rec->size, cf->flags))
+					rec->ptr, rec->size, cf->flags)))
 			break;
 
 	if (!rcrec) {
@@ -130,8 +132,95 @@ static int xdl_classify_record(xdlclassifier_t *cf, xrecord_t **rhash, unsigned
 }
 
 
+static void xdl_trim_head(mmfile_t *mf1, mmfile_t *mf2, xpparam_t const *xpp,
+			  xdfile_t *xdf1, xdfile_t *xdf2) {
+
+	long trimmed = 0, recovered = 0;
+	long smaller = XDL_MIN(mf1->size, mf2->size);
+	char const *p1, *p2;
+	char const *cur, *top;
+
+	/* part 1: blocks */
+	p1 = mf1->ptr;
+	p2 = mf2->ptr;
+
+	top = p1 + smaller;
+
+	while (XDL_TRIM_BLK + trimmed <= smaller && !memcmp(p1, p2, XDL_TRIM_BLK)) {
+		trimmed += XDL_TRIM_BLK;
+		p1 += XDL_TRIM_BLK;
+		p2 += XDL_TRIM_BLK;
+	}
+
+	while (recovered < trimmed)
+		if (*(p1 - recovered++) == '\n')
+			break;
+	p1 -= recovered;
+	p2 -= recovered;
+
+	/* part 2: line based */
+	cur = p1;
+	while (cur < top
+		&& (cur = memchr(cur, '\n', top - cur))
+		&& !memcmp(p1, p2, ++cur - p1)) {
+		p2 += cur - p1;
+		p1 = cur;
+	}
+
+	xdf1->rstart = p1;
+	xdf2->rstart = p2;
+}
+
+
+static void xdl_trim_tail(mmfile_t *mf1, mmfile_t *mf2, xpparam_t const *xpp,
+			  xdfile_t *xdf1, xdfile_t *xdf2) {
+
+	long trimmed = 0, recovered = 0;
+	long smaller = XDL_MIN(mf1->size, mf2->size);
+	long blk;
+	char const *p1 = mf1->ptr + mf1->size;
+	char const *p2 = mf2->ptr + mf2->size;
+	char const *cur, *top;
+
+	while (XDL_TRIM_BLK + trimmed <= smaller && !memcmp(p1 - XDL_TRIM_BLK, p2 - XDL_TRIM_BLK, XDL_TRIM_BLK)) {
+		trimmed += XDL_TRIM_BLK;
+		p1 -= XDL_TRIM_BLK;
+		p2 -= XDL_TRIM_BLK;
+	}
+
+	while (recovered < trimmed) {
+		if (p1[recovered] == '\n')
+			break;
+		recovered++;
+	}
+	p1 += recovered;
+	p2 += recovered;
+
+	top = p1 - (smaller - (top - p1));
+	cur = p1;
+
+	while (cur >= top
+		&& (cur = memrchr(top, '\n', cur - top))) {
+		blk = p1 - cur;
+		if (memcmp(p1 - blk, p2 - blk, blk))
+			break;
+		p1 -= blk;
+		p2 -= blk;
+	}
+	xdf1->rend = p1;
+	xdf2->rend = p2;
+}
+
+
+static void xdl_set_dend(xdfile_t *xdf, long lim, long ntail)
+{
+	xdf->dend = xdf->nrec - XDL_MIN(lim - xdf->dstart, ntail) - 1;
+}
+
+
 static int xdl_prepare_ctx(mmfile_t *mf, long narec, xpparam_t const *xpp,
-			   xdlclassifier_t *cf, xdfile_t *xdf) {
+			   xdlclassifier_t *cf, xdfile_t *xdf,
+			   xrecord_t **arec, long *ntail) {
 	unsigned int hbits;
 	long nrec, hsize, bsize;
 	unsigned long hav;
@@ -161,10 +250,21 @@ static int xdl_prepare_ctx(mmfile_t *mf, long narec, xpparam_t const *xpp,
 	memset(rhash, 0, hsize * sizeof(xrecord_t *));
 
 	nrec = 0;
+	xdf->dstart = *ntail = 0;
 	if ((cur = blk = xdl_mmfile_first(mf, &bsize)) != NULL) {
 		for (top = blk + bsize; cur < top; ) {
 			prev = cur;
-			hav = xdl_hash_record(&cur, top, xpp->flags);
+			if (cur > xdf->rend)
+				(*ntail)++;
+			if (cur < xdf->rstart) {
+				if (arec)
+					cur += (arec++)[0]->size;
+				else
+					cur = memchr(cur, '\n', top - cur) + 1;
+				hav = 0;
+				xdf->dstart++;
+			} else
+				hav = xdl_hash_record(&cur, top, xpp->flags);
 			if (nrec >= narec) {
 				narec *= 2;
 				if (!(rrecs = (xrecord_t **) xdl_realloc(recs, narec * sizeof(xrecord_t *))))
@@ -200,8 +300,6 @@ static int xdl_prepare_ctx(mmfile_t *mf, long narec, xpparam_t const *xpp,
 	xdf->rindex = rindex;
 	xdf->nreff = 0;
 	xdf->ha = ha;
-	xdf->dstart = 0;
-	xdf->dend = nrec - 1;
 
 	return 0;
 
@@ -229,7 +327,9 @@ static void xdl_free_ctx(xdfile_t *xdf) {
 
 int xdl_prepare_env(mmfile_t *mf1, mmfile_t *mf2, xpparam_t const *xpp,
 		    xdfenv_t *xe) {
+	long lim;
 	long enl1, enl2;
+	long ntail1, ntail2;
 	xdlclassifier_t cf;
 
 	enl1 = xdl_guess_lines(mf1) + 1;
@@ -240,18 +340,25 @@ int xdl_prepare_env(mmfile_t *mf1, mmfile_t *mf2, xpparam_t const *xpp,
 		return -1;
 	}
 
-	if (xdl_prepare_ctx(mf1, enl1, xpp, &cf, &xe->xdf1) < 0) {
+	xdl_trim_head(mf1, mf2, xpp, &xe->xdf1, &xe->xdf2);
+	xdl_trim_tail(mf1, mf2, xpp, &xe->xdf1, &xe->xdf2);
+
+	if (xdl_prepare_ctx(mf1, enl1, xpp, &cf, &xe->xdf1, NULL, &ntail1) < 0) {
 
 		xdl_free_classifier(&cf);
 		return -1;
 	}
-	if (xdl_prepare_ctx(mf2, enl2, xpp, &cf, &xe->xdf2) < 0) {
+	if (xdl_prepare_ctx(mf2, enl2, xpp, &cf, &xe->xdf2, xe->xdf1.recs, &ntail2) < 0) {
 
 		xdl_free_ctx(&xe->xdf1);
 		xdl_free_classifier(&cf);
 		return -1;
 	}
 
+	lim = XDL_MIN(xe->xdf1.nrec, xe->xdf2.nrec);
+	xdl_set_dend(&xe->xdf1, lim, ntail1);
+	xdl_set_dend(&xe->xdf2, lim, ntail2);
+
 	xdl_free_classifier(&cf);
 
 	if (!(xpp->flags & XDF_PATIENCE_DIFF) &&
@@ -403,39 +510,9 @@ static int xdl_cleanup_records(xdfile_t *xdf1, xdfile_t *xdf2) {
 }
 
 
-/*
- * Early trim initial and terminal matching records.
- */
-static int xdl_trim_ends(xdfile_t *xdf1, xdfile_t *xdf2) {
-	long i, lim;
-	xrecord_t **recs1, **recs2;
-
-	recs1 = xdf1->recs;
-	recs2 = xdf2->recs;
-	for (i = 0, lim = XDL_MIN(xdf1->nrec, xdf2->nrec); i < lim;
-	     i++, recs1++, recs2++)
-		if ((*recs1)->ha != (*recs2)->ha)
-			break;
-
-	xdf1->dstart = xdf2->dstart = i;
-
-	recs1 = xdf1->recs + xdf1->nrec - 1;
-	recs2 = xdf2->recs + xdf2->nrec - 1;
-	for (lim -= i, i = 0; i < lim; i++, recs1--, recs2--)
-		if ((*recs1)->ha != (*recs2)->ha)
-			break;
-
-	xdf1->dend = xdf1->nrec - i - 1;
-	xdf2->dend = xdf2->nrec - i - 1;
-
-	return 0;
-}
-
-
 static int xdl_optimize_ctxs(xdfile_t *xdf1, xdfile_t *xdf2) {
 
-	if (xdl_trim_ends(xdf1, xdf2) < 0 ||
-	    xdl_cleanup_records(xdf1, xdf2) < 0) {
+	if (xdl_cleanup_records(xdf1, xdf2) < 0) {
 
 		return -1;
 	}
diff --git a/xdiff/xtypes.h b/xdiff/xtypes.h
index 2511aef..6330a9f 100644
--- a/xdiff/xtypes.h
+++ b/xdiff/xtypes.h
@@ -51,6 +51,7 @@ typedef struct s_xdfile {
 	unsigned int hbits;
 	xrecord_t **rhash;
 	long dstart, dend;
+	const char *rstart, *rend;
 	xrecord_t **recs;
 	char *rchg;
 	long *rindex;
